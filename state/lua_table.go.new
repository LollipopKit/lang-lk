package state

import (
	"fmt"
	"math"
	"sync"
)

type kv struct {
	key any
	val any
}
type luaTable struct {
	metatable *luaTable
	list []kv
	lock *sync.RWMutex
}

func newLuaTable(nArr, nRec int) *luaTable {
	t := &luaTable{
		list: make([]kv, 0),
		lock: new(sync.RWMutex),
	}
	return t
}

func (self *luaTable) hasMetafield(fieldName string) bool {
	return self.metatable != nil &&
		self.metatable.get(fieldName) != nil
}

func (self *luaTable) len() int {
	self.lock.RLock()
	defer self.lock.RUnlock()
	return len(self.list)
}

func (self *luaTable) get(key luaValue) luaValue {
	self.lock.RLock()
	defer self.lock.RUnlock()
	switch key.(type) {
	case nil:
		return nil
	case float64, float32, int, int64:
		idx, ok := key.(int64)
		if !ok {
			panic(fmt.Sprintf("invalid index %v", key))
		}
		if idx >= 1 && idx <= int64(len(self.list)) {
			return self.list[idx-1]
		}
	default:
		for _, kv := range self.list {
			if kv.key == key {
				return kv.val
			}
		}
	}
	return nil
}

func (self *luaTable) put(key, val luaValue) {
	if key == nil {
		panic("table index is nil!")
	}
	if f, ok := key.(float64); ok && math.IsNaN(f) {
		panic("table index is NaN!")
	}

	delete := key == nil

	self.lock.Lock()
	defer self.lock.Unlock()
	switch key.(type) {
	case float64, float32, int, int64:
		idx, ok := key.(int64)
		if !ok {
			panic(fmt.Sprintf("invalid index %v", key))
		}
		if idx >= 1 && idx <= int64(len(self.list)) {
			if delete {
				self.list = append(self.list[:idx-1], self.list[idx:]...)
			} else {
				self.list[idx-1] = kv{key, val}
			}
		}
	default:
		for i, item := range self.list {
			if item.key == key {
				if delete {
					self.list = append(self.list[:i], self.list[i+1:]...)
				} else {
					self.list[i] = kv{key, val}
				}
			}
		}
	}
}

func (self *luaTable) nextKey(key luaValue) luaValue {
	self.lock.RLock()
	defer self.lock.RUnlock()
	for idx, item := range self.list {
		if item.key == key {
			if idx == len(self.list)-1 {
				return nil
			}
			return self.list[idx+1].key
		}
	}
	return nil
}
